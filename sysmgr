#!/bin/sh -e

###########################################################
# A modular system-supervisor written in POSIX shell      #
# written with Carbs Linux[1] and KISS Linux[2] in mind.  #
#                                                         #
# [1]: https://carbslinux.org                             #
# [2]: https://k1ss.org                                   #
#                                                         #
# Copyright (c) 2020 - Cem Keylan                         #
# See LICENSE for copyright information                   #
#                                                         #
# Please report bugs to <cem at ckyln dot com>            #
# or open an issue at                                     #
# https://github.com/cemkeylan/sysmgr                     #
###########################################################


out()   { printf '%s\n' "$@" >&2 ;}
error() { printf 'error: %s\n' "$@" >&2 ;}
die()   { printf 'error: %s\n' "$@" "exiting..." >&2 ; exit 1 ;}

RUNDIR="${RUNDIR:-/run/sysmgr}"
SYSDIR="${SYSDIR:-/var/sysmgr}"
version=0.2.0

usage() {
    # Define a different out function just for the usage function.
    out() {
        # This prints the synopsis, adds an empty line, prints arguments,
        # adds another empty line and prints version information.
        printf '%s\n' "Usage: ${SYNOPSIS:-${0##*/}}" "" "$@" "" "sysmgr-$version" >&2
    }
    case "${0##*/}" in
        sysmgr) out \
                    "Does not accept command line options" "" \
                    "Can be configured from the environment variables" "RUNDIR, SYSDIR" "" \
                    "Example: SYSDIR=\"$HOME/.service\" RUNDIR=\"$HOME/.run\" sysmgr" ;;
        runsyssv) SYNOPSIS="runsyssv <service>" out \
                          "Runs the given service as the parent process." \
                          "Redirects received signals to its service." ;;
        svctl) SYNOPSIS="svctl <command> <service>" out \
                       "start/stop/restart  Starts/stops/restarts a service" \
                       "kill                Sends a SIGKILL to the service" \
                       "once                Starts a service once" \
                       "status              Checks the service status" \
                       "up/down             Same as start/stop" ;;
    esac
    exit 1
}

checkprocess() {

    # This function checks if the process is still alive and
    # returns 0 or 1 accordingly. It checks the /proc directory
    # first (which exists in most Linux systems, but not all)
    # and fallbacks to kill if it doesn't. There are three
    # reasons for preferring /proc over kill:
    #
    # 1: We don't need to spawn an extra process.
    # 2: We can check processes we don't own, which eliminates
    # the requirement of being root.
    # 3: Checking the existence of a directory is much faster and
    # more efficient than sending a signal to a process.
    [ -d /proc ] || {
        kill -0 "$1" || return 1
        return 0
    }
    [ -d "/proc/$1" ] || return 1
    return 0
}

cleanup() {

    # Clean the service run directory so that it can be
    # restarted. Do not remove the run directory if lock
    # file exists.

    [ -e "${RUNDIR:?}/${service##*/}/lock" ] && return 0
    rm -rf "${RUNDIR:?}/${service##*/}"

}

term() {

    # This function is executed when the sysmgr receives an
    # interrupt or a hangup signal. It enters the termination
    # state where it forwards SIGTERM to every other runsyssv
    # process that have their process ids in the RUNDIR

    for process in "${RUNDIR:?}"/*/syspid ; do
        kill -15 "$(cat "$process")" 2>/dev/null
    done

    # Wait for the redirections to happen
    sleep 1

    # Remove the RUNDIR so we can do a fresh start when we
    # are re-initiating the program.
    rm -rf "${RUNDIR}"

    exit 0
}

redirectsignal() {

    # We redirect signal that was sent to runsyssv so that
    # those programs are stopped with the exact kill command.
    # Adding a lock file ensures that the directory is not
    # cleaned up.
    sig="$1"

    printf '%s\n' "${sig:-15}" > "${RUNDIR:?}/${service##*/}/lock"
    kill "-${sig:-15}" "$svpid" 2>/dev/null

}

fn_sysmgr() {
    [ "$1" ] && usage
    
    # Start sanity checks. We first check that we have
    # the "$SYSDIR" variable. We then check whether the
    # given SYSDIR exists, and has service files installed.
    [ "$SYSDIR" ] || die "Please specify service directory"
    [ -d "$SYSDIR" ] || die "$SYSDIR does not exist."
    [ "$(ls -1 "$SYSDIR")" ] || error "No service file is found"
    mkdir -p "$RUNDIR" || die

    # Add pid to $RUNDIR before starting loops
    printf '%s\n' "$$" > "$RUNDIR/pid"

    # We redirect signals to the 'term' function so that
    # we send kill signals to all sysmgr processes.
    trap term INT HUP QUIT ABRT TERM

    # Lots of loops here. The first while loop is to
    # make sure that the sysmgr does not exist. The
    # for loop is to run every single service on the
    # $SYSDIR. We then fork the runsyssv function to
    # the background. This ensures that we don't have
    # to wait until runsyssv has finished, which is a
    # program that is not supposed to exit.
    while sleep 1 ; do
        [ "$(ls -A "$SYSDIR" )" ] && for service in "$SYSDIR"/* ; do
            [ -x "$service" ] || error "$service is not an executable file"
            ! [ -d "$RUNDIR/${service##*/}" ] && runsyssv "$service" &
        done
    done
}

fn_runsyssv() {

    [ "$1" ] || usage
    case "$1" in -h|--help|help) usage ;; esac

    # Record service name in a variable
    service="$1"

    # This is the simplest way of checking whether a
    # service is running (or killed by the user with
    # ctl, so that it does not run again).
    [ -e "$RUNDIR/${service##*/}" ] && exit 1

    # Create the run directory for the service where
    # we will be adding the pid value when we start
    # the process.
    mkdir -p "$RUNDIR/${service##*/}"
    
    # Start the service script. If the service fails
    # exit with failure code 1. If the service exits
    # without a failure (which it probably shouldn't)
    # exit with code 0
    "$service" &
    svpid="$!"
    printf '%s\n' "$svpid" > "$RUNDIR/${service##*/}/pid"
    printf '%s\n' "$$" > "$RUNDIR/${service##*/}/syspid"
    
    for sig in INT HUP QUIT ABRT TERM ; do
        # We want to trap every signal with their own
        # value so that we kill the service with the
        # requested signal.
        # shellcheck disable=SC2064
        trap "redirectsignal $sig" $sig
    done

    # check whether services are alive
    while checkprocess "$svpid" ; do sleep 1 ; done

    # Do a cleanup when the service is killed
    cleanup
}

fn_svctl() {
    [ -d "$RUNDIR" ] || die \
         "Could not find $RUNDIR (RUNDIR)" "Are you sure that sysmgr is working?"
    [ "$2" ] || usage
    [ -d "${RUNDIR:?}/$2" ] || die "service $2 could not be found."
    case "$1" in
        stat|status)
            # The usage of && || is for 'if else', but since 'out' will
            # always return 0, this usage is okay.
            # shellcheck disable=SC2015
            checkprocess "$(cat "${RUNDIR:?}/$2/pid")" &&
                out "OK" || { out "DOWN" ; exit 1 ;}
            ;;
        restart)
            fn_svctl kill "$2"
            fn_svctl start "$2"
            ;;
        kill)
            printf '9\n' > "${RUNDIR:?}/$2/lock"
            kill -9 "$(cat "${RUNDIR:?}/$2/pid")" 2>/dev/null
            ;;
        down|stop)
            printf '15\n' > "${RUNDIR:?}/$2/lock"
            kill -15 "$(cat "${RUNDIR:?}/$2/pid")" 2>/dev/null
            ;;
        up|start)
            rm -rf "${RUNDIR:?}/${2}"
            ;;
        once)
            fn_svctl start "$2"
            sleep 1  # Wait for the service to go up
            printf 'once\n' > "${RUNDIR:?}/$2/lock"
            ;;
        *)
            usage
            ;;
    esac
}

main() {
    # Call the appropriate function depending on the
    # name of the program.
    case "${0##*/}" in
        sysmgr) fn_sysmgr "$@" ;;
        runsyssv) fn_runsyssv "$@" ;;
        svctl) fn_svctl "$@" ;;
        *) printf '%s is not a function\n' "${0##*/}" ; exit 1 ;;
    esac
}

main "$@"
